#!/bin/bash

#log path - should be consistent with other scripts
#setup.sh will insert LOG's definition here

COMMIT=$1

#data about project
#EXTENSIONS=( '.c' '.cc' '.h') #not working here - edit on line 155 instead
WORK_TAGS=(MPI OpenMP Cuda Kokkos debugging optimisation "domain specific work")

#initialise temp
echo '' > $LOG

#mark the start of user-provided info
echo '{"user_responses":' >> $LOG

#copy over the original commit message
#(after removing any comments)
#as a description of the work done
printf '\t{"description":"' >> $LOG
grep -v '^#' $COMMIT >> $LOG
printf '"},\n' >> $LOG

#enable user input; assigns stdin to keyboard
exec < /dev/tty

#ask the user if they want to record any logging info
#for this commit
while [ "$record_log" != 'y' ] \
	 && [ "$record_log" != 'n' ]
do
	printf 'Would you like to record a productivity'
	printf 'log for this commit? (y/n)'
	read record_log
done

if [ "$record_log" = 'n' ]; then
	#close std out
	exec <&-
	
	#delete the log that we've started to build
	rm $LOG

	#and stop the script
	exit 0
fi

#get an estimate of the difficulty of the work
#(must be an integer between 1 and 5)
difficulty=0
while [[ ! $difficulty =~ ^[0-9]+$ ]] \
      || [ 1 -gt $difficulty ] \
      || [ $difficulty -gt 5 ]
do
	echo 'Please rate the difficulty of the work'
	echo 'contained in this commit on a scale of 1-5:'
	echo '(1 - very easy, 3 - about average, 5 - very hard)'
	read difficulty
done
printf '\t{"difficulty":%d},\n' $difficulty >> $LOG

#get an estimate of time spent on this commit
time_spent=
while [[ ! $time_spent =~ ^[0-9]+(\.[0-9]+)?$ ]]; do
	echo 'Please estimate how many hours you spent'
	echo 'on the work involved in this commit'
	read time_spent
done
printf '\t{"time_spent":%f},' $time_spent >> $LOG

#ask the user about which tags are relevant to their work
printf '\t{"tags":\n' >> $LOG
for ((i = 0; i < ${#WORK_TAGS[@]}; i++)) ; do
	tag_used=
	tag="${WORK_TAGS[$i]}"
	
	#add trailing comma and newline if this isn't the
	#first tag
	if (($i != 0)); then
		printf ',\n' >> $LOG
	fi

	#read in a yes or no answer
	while [ "$tag_used" != 'y' ] \
     && [ "$tag_used" != 'n' ]
	do
		printf 'Did this work involve %s? (y/n)' "$tag"
		read tag_used
	done
	
	#write out the answer as a boolean
	if [ $tag_used = 'y' ]; then
		printf '\t\t{"%s":true}' "$tag" >> $LOG
	else
		printf '\t\t{"%s":false}' "$tag" >> $LOG
	fi
done
#end the tag section
printf '\n\t}\n' >> $LOG

#close stdin back up
exec <&-

#mark the end of user-provided info
echo '}' >> $LOG

#copy over the autogenerated commented out lines
printf '{"status":"' >> $LOG
grep "^#" $COMMIT >> $LOG
printf '"}' >> $LOG

#generate the name arguement to find from
#a list of important file extensions
#name_arg=
#for ((i = 0; i < ${#EXTENSIONS[@]}; i++)) ; do
#	extension="${EXTENSIONS[$i]}"
#
#	#only add the trailing or if this isn't the first type
#	if (($i != 0)) ; then
#		name_arg=$name_arg' -o '
#  fi
#
#	#add the current extension
#	name_arg=$name_arg'-name "*'$extension'"'
#done

#get a list of all the files in the main directory of the repo,
#with each file described in JSON:
#	{"name":$filename,{"size":$bytes},{"last_modified":$UNIX_epoch_time}}
files=$(find . -type f \( -name "*.c" -o -name "*.cc" -o -name "*.h" \))

#write the list to the commit file
printf '{"files":\n' >> $LOG
if [ ! -z "$files" ]; then
	for ((i = 0; i < ${#files[@]}; i++)); do
		file="${files[$i]}"

		#only add the trailing comma and newline if this
		#isn't the first file
		if (($i != 0)) ; then
			printf ',\n' >> $LOG
		fi

		#write the info on the current file
		stat --printf="{\"name\":\"%n\",\"size\":%s,\"last_modified\":%Y}" \
		$file >> $LOG
	done
fi
printf '\n}\n' >> $LOG

#git info will be stored by post-commit
