#!/bin/bash

COMMIT=$1

#folder/file paths - should be consistent with other scripts
#MAIN_REPO_PATH=$PWD
#NOTE: this script is run from the top level
#      of the repo NOT in the .git folder
#LOGGING_REPO_PATH=$MAIN_REPO_PATH/logs
TEMP=$LOGGING_REPO_PATH/.git/temp.txt

#data about project
#EXTENSIONS=( '.c' '.cc' '.h') #not working here - edit on line 155 instead
WORK_TAGS=(MPI OpenMP Cuda Kokkos debugging optimisation "domain specific work")

echo $(git rev-parse --abbrev-ref HEAD)

#initialise temp
echo '' > $TEMP

#mark the start of user-provided info
echo '{"user_responses":' >> $TEMP

#copy over the original commit message
#(after removing any comments)
#as a description of the work done
printf '\t{"description":"' >> $TEMP
grep -v '^#' $COMMIT >> $TEMP
printf '"},\n' >> $TEMP

#enable user input; assigns stdin to keyboard
exec < /dev/tty

#get an estimate of the difficulty of the work
#(must be an integer between 1 and 5)
difficulty=0
while [[ ! $difficulty =~ ^[0-9]+$ ]] \
      || [ 1 -gt $difficulty ] \
      || [ $difficulty -gt 5 ]
do
	echo 'Please rate the difficulty of the work'
	echo 'contained in this commit on a scale of 1-5:'
	echo '(1 - very easy, 3 - about average, 5 - very hard)'
	read difficulty
done
printf '\t{"difficulty":%d},\n' $difficulty >> $TEMP

#get an estimate of time spent on this commit
time_spent=
while [[ ! $time_spent =~ ^[0-9]+(\.[0-9]+)?$ ]]; do
	echo 'Please estimate how many hours you spent'
	echo 'on the work involved in this commit'
	read time_spent
done
printf '\t{"time_spent":%f},' $time_spent >> $TEMP

#ask the user about which tags are relevant to their work
printf '\t{"tags":\n' >> $TEMP
for ((i = 0; i < ${#WORK_TAGS[@]}; i++)) ; do
	tag_used=
	tag="${WORK_TAGS[$i]}"
	
	#add trailing comma and newline if this isn't the
	#first tag
	if (($i != 0)); then
		printf ',\n' >> $TEMP
	fi

	#read in a yes or no answer
	while [ "$tag_used" != 'y' ] \
     && [ "$tag_used" != 'n' ]
	do
		printf 'Did this work involve %s? (y/n)' "$tag"
		read tag_used
	done
	
	#write out the answer as a boolean
	if [ $tag_used = 'y' ]; then
		printf '\t\t{"%s":true}' "$tag" >> $TEMP
	else
		printf '\t\t{"%s":false}' "$tag" >> $TEMP
	fi
done
#end the tag section
printf '\n\t}\n' >> $TEMP

#close stdin back up
exec <&-

#mark the end of user-provided info
echo '}' >> $TEMP

#copy over the autogenerated commented out lines
printf '{"status":"' >> $TEMP
grep "^#" $COMMIT >> $TEMP
printf '"}' >> $TEMP

#generate the name arguement to find from
#a list of important file extensions
#name_arg=
#for ((i = 0; i < ${#EXTENSIONS[@]}; i++)) ; do
#	extension="${EXTENSIONS[$i]}"
#
#	#only add the trailing or if this isn't the first type
#	if (($i != 0)) ; then
#		name_arg=$name_arg' -o '
#  fi
#
#	#add the current extension
#	name_arg=$name_arg'-name "*'$extension'"'
#done

#get a list of all the files in 
#the main directory of the repo,
#with each file described in JSON:
#	{"name":$filename,{"size":$bytes},{"last_modified":$UNIX_epoch_time}}
files=$(find . -type f \( -name "*.c" -o -name "*.cc" -o -name "*.h" \))
echo $files
echo $name_arg

#write the list to the commit file
printf '{"files":\n' >> $TEMP
if [ ! -z "$files" ]; then
	for ((i = 0; i < ${#files[@]}; i++)); do
		file="${files[$i]}"

		#only add the trailing comma and newline if this
		#isn't the first file
		if (($i != 0)) ; then
			printf ',\n' >> $TEMP
		fi

		#write the info on the current file
		stat --printf="{\"name\":\"%n\",\"size\":%s,\"last_modified\":%Y}" \
		$file >> $TEMP
	done
fi
printf '\n}\n' >> $TEMP
